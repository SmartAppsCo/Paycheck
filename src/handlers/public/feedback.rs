//! Feedback and crash report handlers.
//!
//! These endpoints allow users with valid JWTs to submit feedback or crash
//! reports. The data is passed through to the project's configured webhook
//! or email - Paycheck does not store any feedback/crash data.

use axum::extract::State;
use axum_extra::{
    TypedHeader,
    headers::{Authorization, authorization::Bearer},
};
use serde::{Deserialize, Serialize};

use crate::db::{AppState, queries};
use crate::error::{AppError, Result, msg};
use crate::extractors::Json;
use crate::feedback::{
    Breadcrumb, CrashData, DeliveryConfig, DeliveryResult, FeedbackData, FeedbackType, JwtContext,
    Priority, StackFrame,
};
use crate::jwt;
use crate::metering::{generate_email_idempotency_key, spawn_email_metering, EmailMeteringEvent};

/// Request body for POST /feedback
#[derive(Debug, Deserialize)]
pub struct FeedbackRequest {
    /// The feedback message (required)
    pub message: String,
    /// User's email for follow-up (optional)
    #[serde(default)]
    pub email: Option<String>,
    /// Feedback type classification
    #[serde(default, rename = "type")]
    pub feedback_type: FeedbackType,
    /// Priority level
    #[serde(default)]
    pub priority: Option<Priority>,
    /// App version (optional, auto-filled by SDK if available)
    #[serde(default)]
    pub app_version: Option<String>,
    /// OS info (optional, auto-filled by SDK if available)
    #[serde(default)]
    pub os: Option<String>,
    /// Arbitrary metadata
    #[serde(default)]
    pub metadata: Option<serde_json::Value>,
}

/// Request body for POST /crash
#[derive(Debug, Deserialize)]
pub struct CrashRequest {
    /// Error type/class (required)
    pub error_type: String,
    /// Error message (required)
    pub error_message: String,
    /// Parsed stack trace (optional)
    #[serde(default)]
    pub stack_trace: Option<Vec<StackFrame>>,
    /// Deduplication fingerprint (auto-generated by SDK)
    #[serde(default)]
    pub fingerprint: Option<String>,
    /// User's email for follow-up (optional)
    #[serde(default)]
    pub user_email: Option<String>,
    /// App version (optional)
    #[serde(default)]
    pub app_version: Option<String>,
    /// OS info (optional)
    #[serde(default)]
    pub os: Option<String>,
    /// Arbitrary metadata
    #[serde(default)]
    pub metadata: Option<serde_json::Value>,
    /// Event breadcrumbs leading up to crash
    #[serde(default)]
    pub breadcrumbs: Option<Vec<Breadcrumb>>,
}

/// Response for both endpoints
#[derive(Debug, Serialize)]
pub struct SubmitResponse {
    pub success: bool,
}

/// Extract and verify JWT, return context and project info
async fn verify_jwt_and_get_context(
    state: &AppState,
    token: &str,
) -> Result<(JwtContext, String, String)> {
    let conn = state.db.get()?;

    // Decode without verification to get product_id for key lookup
    let unverified_claims = jwt::decode_unverified(token)?;

    // Look up product to get project
    let product = queries::get_product_by_id(&conn, &unverified_claims.product_id)?
        .ok_or_else(|| AppError::BadRequest(msg::INVALID_TOKEN_PRODUCT.into()))?;

    // Get project to get public key
    let project = queries::get_project_by_id(&conn, &product.project_id)?
        .ok_or_else(|| AppError::Internal(msg::PROJECT_NOT_FOUND.into()))?;

    // Verify JWT signature
    let verified_claims = jwt::verify_token(token, &project.public_key)?;

    // Get the license_id from the verified token's subject claim
    let license_id = verified_claims
        .subject
        .ok_or_else(|| AppError::BadRequest("Token missing subject claim".into()))?;

    // Build JWT context for delivery
    let jwt_context = JwtContext {
        license_id,
        tier: verified_claims.custom.tier,
        features: verified_claims.custom.features,
        device_id: verified_claims.custom.device_id,
        device_type: verified_claims.custom.device_type,
        product_id: verified_claims.custom.product_id,
    };

    Ok((jwt_context, project.id, project.name))
}

/// POST /feedback - Submit user feedback
pub async fn submit_feedback(
    State(state): State<AppState>,
    TypedHeader(auth): TypedHeader<Authorization<Bearer>>,
    Json(req): Json<FeedbackRequest>,
) -> Result<Json<SubmitResponse>> {
    let token = auth.token();

    // Extract and verify JWT
    let (jwt_context, project_id, project_name) =
        verify_jwt_and_get_context(&state, token).await?;

    // Get project for delivery config
    let conn = state.db.get()?;
    let project = queries::get_project_by_id(&conn, &project_id)?
        .ok_or_else(|| AppError::Internal(msg::PROJECT_NOT_FOUND.into()))?;

    // Get effective email config with 3-level lookup: product → project → org
    // This ensures project/product-level email configs are respected for feedback
    // Must be done before DeliveryConfig creation which partially moves project fields
    let org = queries::get_organization_by_id(&conn, &project.org_id)?;
    let product = queries::get_product_by_id(&conn, &jwt_context.product_id)?;
    let org_resend_key = match (&org, &product) {
        (Some(org), Some(product)) => {
            queries::get_effective_email_config(&conn, product, &project, org, &state.master_key)
                .ok()
                .flatten()
                .map(|(key, _source)| key)
        }
        _ => None,
    };

    let config = DeliveryConfig {
        webhook_url: project.feedback_webhook_url.clone(),
        email: project.feedback_email,
    };

    if !config.is_configured() {
        return Err(AppError::BadRequest(
            "Feedback not configured for this project".into(),
        ));
    }

    // Build feedback data
    let data = FeedbackData {
        message: req.message,
        email: req.email,
        feedback_type: req.feedback_type,
        priority: req.priority,
        app_version: req.app_version,
        os: req.os,
        metadata: req.metadata,
    };

    // Deliver feedback (uses org's Resend key if available, otherwise system key)
    let result = state
        .delivery_service
        .deliver_feedback(
            &config,
            &project_id,
            &project_name,
            jwt_context,
            data,
            org_resend_key.as_deref(),
        )
        .await?;

    // Fire-and-forget metering event
    let delivery_method = match result {
        DeliveryResult::EmailSent if org_resend_key.is_some() => "org_key",
        DeliveryResult::EmailSent => "system_key",
        DeliveryResult::WebhookDelivered => "webhook",
    };

    spawn_email_metering(
        state.http_client.clone(),
        state.metering_webhook_url.clone(),
        EmailMeteringEvent {
            event: "feedback_sent".to_string(),
            org_id: project.org_id.clone(),
            project_id: project_id.clone(),
            license_id: None,
            product_id: None,
            delivery_method: delivery_method.to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            idempotency_key: generate_email_idempotency_key(),
        },
    );

    Ok(Json(SubmitResponse { success: true }))
}

/// POST /crash - Report a crash
pub async fn report_crash(
    State(state): State<AppState>,
    TypedHeader(auth): TypedHeader<Authorization<Bearer>>,
    Json(req): Json<CrashRequest>,
) -> Result<Json<SubmitResponse>> {
    let token = auth.token();

    // Extract and verify JWT
    let (jwt_context, project_id, project_name) =
        verify_jwt_and_get_context(&state, token).await?;

    // Get project for delivery config
    let conn = state.db.get()?;
    let project = queries::get_project_by_id(&conn, &project_id)?
        .ok_or_else(|| AppError::Internal(msg::PROJECT_NOT_FOUND.into()))?;

    // Get effective email config with 3-level lookup: product → project → org
    // This ensures project/product-level email configs are respected for crash reports
    // Must be done before DeliveryConfig creation which partially moves project fields
    let org = queries::get_organization_by_id(&conn, &project.org_id)?;
    let product = queries::get_product_by_id(&conn, &jwt_context.product_id)?;
    let org_resend_key = match (&org, &product) {
        (Some(org), Some(product)) => {
            queries::get_effective_email_config(&conn, product, &project, org, &state.master_key)
                .ok()
                .flatten()
                .map(|(key, _source)| key)
        }
        _ => None,
    };

    let config = DeliveryConfig {
        webhook_url: project.crash_webhook_url.clone(),
        email: project.crash_email,
    };

    if !config.is_configured() {
        return Err(AppError::BadRequest(
            "Crash reporting not configured for this project".into(),
        ));
    }

    // Build crash data
    let data = CrashData {
        error_type: req.error_type,
        error_message: req.error_message,
        stack_trace: req.stack_trace,
        fingerprint: req.fingerprint,
        user_email: req.user_email,
        app_version: req.app_version,
        os: req.os,
        metadata: req.metadata,
        breadcrumbs: req.breadcrumbs,
    };

    // Deliver crash report (uses org's Resend key if available, otherwise system key)
    let result = state
        .delivery_service
        .deliver_crash(
            &config,
            &project_id,
            &project_name,
            jwt_context,
            data,
            org_resend_key.as_deref(),
        )
        .await?;

    // Fire-and-forget metering event
    let delivery_method = match result {
        DeliveryResult::EmailSent if org_resend_key.is_some() => "org_key",
        DeliveryResult::EmailSent => "system_key",
        DeliveryResult::WebhookDelivered => "webhook",
    };

    spawn_email_metering(
        state.http_client.clone(),
        state.metering_webhook_url.clone(),
        EmailMeteringEvent {
            event: "crash_sent".to_string(),
            org_id: project.org_id.clone(),
            project_id: project_id.clone(),
            license_id: None,
            product_id: None,
            delivery_method: delivery_method.to_string(),
            timestamp: chrono::Utc::now().timestamp(),
            idempotency_key: generate_email_idempotency_key(),
        },
    );

    Ok(Json(SubmitResponse { success: true }))
}
